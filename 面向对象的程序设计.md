<p id="title"></p>

## 目录 ##

:arrow_down:<a href="#a1">1.理解对象</a>

:arrow_down:<a href="#a2">2.创建对象</a>


<p id="a1"></p>

## :gem: 理解对象 ## 

:arrow_double_up:<a href = "#title">返回目录</a>

ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或者函数。”严格来说，这相当于说对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而每个名字都映射到一个值，我们可以把ECMhAScript的对象理解为散列表：无非就是一组名键对，其中值可以是数据或函数。

前面说过Object类型可以创建一个对象。创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性与方法，如下：

```javascript
var person = new Object();

person.name = "Lumnca";
person.age = 18;

person.say = function(s){
  alert("Lumnca : "+s);
}
```

上面创建了一个名为person的对象，并为它添加了两个属性name，age和一个方法say。这是一种写法，还可以使用对象字面量成为创建这种对象的首选模式。前面的例子用对象字面量可以写成这样：

```javascript
var person = {
  name : "Lumnca",
  age : 17,
  say : function(s){
    alert("Lumnca : "+s);
  }
}
```

可以看到这种样式就与键值对一样，这就是上面所说的名键对。到现在这种写法更为普遍

#### :dizzy:属性类型 ####

属性用于描述对象的某些数据，比如姓名与年龄这样的属性，这些属性是由具体的数值来构成的。但是对于某些对象的动作属性以及行为那就不能靠单纯的数据来表示。

**1.数据属性**

数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性。

```
[[Configurable]] : 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认为true。

[[Enumerable]] : 表示能否通过for-in循环返回属性，默认为true。

[[Writable]] : 表示能否修改属性值，默认为true。

[[Value]] : 包含这个属性的数据值。读取属性值的时候，从这个位置读，写，修改都保存在这个位置，默认值为undefined。
```

要修改默认的属性值，需要使用Object.defineProperty()方法，这个方法接受三个参数：属性所在的对象，参数名字，和一个描述符对象。其中描述符对象属性必须是
configurable，enumerable，writable，value其中之一或者多个。

如下对对象属性不可修改进行声明：

```javascript
var person = {
  name : "Lumnca",
  age : 17
}

Object.defineProperty(person,"name",{
  writable : false
})

person.name = "kay";

alert(person.name);  //lumnca

```

如上，并不会报错，如果在严格模式下，会出现报错。上面我们属性，只对修改特性进行了修改，如果这个对象中没有任何一个属性，则会将对configurable，enumerable，writable默认值全部由true改为false。大多数情况下我们都用不到这个方法，但是理解这些概念对理解js对象十分有用。

**2.访问器属性**

访问器属性用来决定属性值是否可修改与可读取。他们包含一对函数：getter和setter。不过这两个函数都不是必须的。在读取对象属性时，会调用geter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入值。访问器有如下4个特性：

```
[[Configurable]] : 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认为true。

[[Enumerable]] : 表示能否通过for-in循环返回属性，默认为true。

[[Get]] : 在读取属性时调用的函数，默认为undefined

[[Set]] : 在写入属性时调用的函数，默认值为undefined
```

与前面的一样，必须使用Object.defineProperty()来定义，如下例子：

```javascript
var person = {
  name : "Lumnca",
  age : 17,
}

Object.defineProperty(person,"age",{
   get : function(){
     return age;
   },
   set : function(a){
     this.age = a;
   }

});
person.age = 26;
alert(person.age);
```

上面就是实现了读写属性的方法，当然现在不需要大家把这两个函数实现，默认的两个函数已经可以完成属性读写，这里只是告诉属性是怎么实现的读写操作的。上面的这样只能对单个属性进行修饰，可以同时对多个进行修饰：

```javascript
var person = {
  name : "Lumnca",
  age : 17,
  num : 0
}

Object.defineProperties(person,{
  name : {
     writable : false
  },
  age : {
    configurable : true
  },
  num : {
    value : 0
  }
})
```

definePropertie()方法可以将多个属性作为对象修改。

#### :dizzy:读取属性的特性 ####

使用Object.getOwnPropertyDescriptor()方法可以获取对象属性的描述的名字，接受两个参数，一是参数对象，而是参数属性名。返回对象，如果是访问器属性这个对象的属性有：configurable，get,set .如果是数据属性，则对象属性有： configurable，enumerable，writable，value。如：

```javascript
var person = {
  name : "Lumnca",
  age : 17,
  num : 0
}
var a = Object.getOwnPropertyDescriptor(person,"age");

alert(a.value);       //17
alert(a.configurable);//true
```

可见可以通过这个方法来查看属性的特性值。

<p id="a2"></p>

## :gem: 创建对象 ## 

:arrow_double_up:<a href = "#title">返回目录</a>

前面说过有两种方式可以创建对象，但是对于很多个对象这样创建起来显得麻烦。为了解决这个问题，人们开始使用工厂模式

#### :dizzy:工厂模式 ####

在其他语言中，我们都知道有构造函数可以快捷创建对象初始化数据实例化对象，在js中工厂模式与构造函数有点类似，可以通过这个来快捷初始化数据。

如下：

```javascript
function createPerson(name,age,id){
   var per = new Object();
   per.name = name;
   per.age = age;
   per.id = id;
   
   return per;
}

var person1 = createPerson("lumnca",21,0317);
var person2 = createPerson("Reilly",19,0527);

alert(person1.name+" : "+person1.age);

alert(person2.name+" : "+person2.age);
```

可以看出这并不想我们所认识的构造函数，而是一个基本的函数，只是在函数内部创建了一个对象，并完成赋值再返回这个对象而已。但是这样却十分的方便实例化多个对象。但是这样有个问题的存在，就是不知道对象的类型，就是没有对象名称，随着JavaScript的发展，新的模式有出现了。

#### :dizzy:构造函数模式 ####

前面说过工厂模式没有类的名称，我们可以通过写类名的构造函数来真的实现构造：

```java
function Person(name,age,id){

   this.name = name;
   this.age = age;
   this.id = id;
   this.say = function(s){
     alert(name+":"+s);
   }
}

var person1 = new Person("lumnca",21,0317);
var person2 = new Person("Reilly",19,0527);

person1.say("Hello!");
person2.say("Hello!")
```

这里我们是使用person类名作为函数名，使得其含有了构造函数的功能，在实例化时可以进行初始化。按照习惯构造函数名我们一般使用大写字母开头。非构造函数用小写开头。正是使用了构造方法才使得可以有类型名：

```javascript
alert(person1.constructor==Person);  //true
```

constructor属性可以返回类类型。也可以使用:

```javascript
alert(person1 instanceof Person);
```

来确认类型。

**构造函数注意点**

构造函数与一般的函数唯一的区别在于调用他们的方式不同，不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法，任何函数通过new操作符来调用，那它就可以作为构造函数，而任何函数不通过new调用，那它和普通函数没有什么区别。下面是通过三种不同方式来获得这个对象，但是各自的作用域以及调用方式不同

```javascript
function Person(name,age,id){

   this.name = name;
   this.age = age;
   this.id = id;
   this.say = function(s){
     alert(name+":"+s);
   }
}

//构造函数创建
var person1 = new Person("lumnca",21,0317);
Person("Reilly",19,0527);

//作为普通函数全局调用解析
person1.say("Hello!");
window.say("Hello!");

//在另一个对象中调用
var person3 = new Object();
Person.call(person3,"Kay",20,0724);
person3.say("Hello!");
```

但是构造函数也并不是没有缺点，在构造函数中，使用this返回该对象的，但是对于参数不同会导致this转向不同的对象，就是作用域链和标识符。








