# ------------------变量，作用域和内存问题--------------- #

<p id="title"></p>

## 目录 ##

:arrow_down:<a href="#a1">1.基本类型和引用类型的值</a>

:arrow_down:<a href="#a2">2.执行环境及作用域</a>

:arrow_down:<a href="#a3">3.垃圾收集</a>

<p id="a1"></p>

## 	:hourglass:基本类型和引用类型的值 ## 

:arrow_double_up:<a href = "#title">返回目录</a>

ECMAScript变量可能包含两种不同的数据类型的值：基本类型值和引用类型值。
   * 基本类型值是指的Number，String,Boolean,Undefined,Null这5中基本类型的值。
   
   * 引用类型值是保存在内存中的对象，Js不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间。
   
### :dart:动态属性 ###

定义基本类型值与引用类型一致，但是对于引用类型的值，我们可以为其添加属性与方法，也可以改变和删除其属性，如下：

```JavaScript
var person = new Object();

person.name = "Lumnca";

alert(person.name);
```

如上操作会弹出Lumnca这个属性值，如果这个对象person不被销毁，它将一直存在，但是我们不能为基本类型添加属性，即使这样不会报错：

```JavaScript
var name = "Lumnca";
name.age = 19;
alert(name.age);
```

这样就会弹出一个undefined未定义的值，这说明只能给引用类型值动态地添加属性。

### :dart:复制变量值 ###

除了上面的动态属性不一样以外，在变量复制上也是不一样的，我们先来看基本类型的变量复制：

```JavaScript
var a = 5;
var b = a;

a = 7;
alert(a);
alert(b);
```

如上a初始化为5，又定义了一个b初始化为a，然后改变a的值，最后输出a=7，b=5，可见两个并没有关系，修改a的值不会对b有影响，也就是说基本类型的值只是复制了变量所对应的值，并不是复制了一个一体的变量引用，当我们再看看引用类型的复制，不一样的是，复制的值其实就是一个副本，也就是一个指针，而这个指针指向的就是存储的堆中的对象，复制操作结束后两个变量实际上指向的都是同一个对象，对其中一个修改会改变另一个的值，如下：

```JavaScript
var obj1 = new Object();
obj1.age = 5;

var obj2 = obj1;
obj1.age = 7;

alert(obj1.age);
alert(obj2.age);
```

最后弹出的都是7，说明引用类型复制其本质上就是对一个变量就行重命名，两个所指的均是同一个对象。

### :dart:传递参数 ###

ECMAScript中所有函数的参数都是按值传递，也就是说和其他语言一样，函数的参数如果不是引用类型，那么在函数里面对参数修改没有任何意义。如下：

```JavaScript
function add(num){
   num +=10;
   return num;
}

var a = 5;

var b = add(a);

alert(a);
alert(b);
```

弹出的值发现a还是5，而b才是15，这是由于参数只是一个基本类型的值复制，并不是引用类型的复制，所以函数里面对参数的修改是不起作用的。但是如果参数是引用类型的那就可以就行修改，如下：
  
```JavaScript
function chageName(person,name){
    person.Name = name;
}
var people = new Object();

chageName(people,"Lumnca");

alert(people.Name);
```


因为引用类型是副本复制，所修改的值会影响到对象的值，所以可以在函数内部修改值。但是在函数内部定义的局部对象就不能改变值，如下：

```JavaScript
function chageName(person,name){
    person.Name = name;
    person = new Object();
    person.Name = "KKKKK";
}

var people = new Object();

chageName(people,"Lumnca");

alert(people.Name);
```

如上最后名称还是Lumnca，因为定义的局部变量在函数结束后，就会被销毁。所以并没有修改值。

### :dart:检测类型 ###

要检测一个变量是不是基本类型，前面说过typeof操作符是最佳的工具，如果返回值是object，即代表是引用类型数据，但是这样用的比较少，通常我们想知道的是它是什么类型的对象，为此ECMAScript提供了instanceof操作符，其语法格式为： `变量 instanceof 数据类型`，他会根据类型是否一致来返回false和true。如下：

```
var people = new Object();

var xiaoming = people;
alert(xiaoming instanceof Object);  //true
alert(xiaoming instanceof Number);  //false
```

<p id="a2"></p>

## 	:hourglass:执行环境及作用域 ## 

:arrow_double_up:<a href = "#title">返回目录</a>

执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之相关的变量对象，环境中定义的所有变量和函数都保存在这个对象中，全局执行环境是最外围的一个执行环境，在Web中是Window对象，因此所有的全局变量和函数都是作为Window对象下的属性和函数创建的。

每个函数都有自己的执行环境，每当执行流进入一个函数时，函数的环境就会进入一个环境中栈中。函数执行完毕后，栈将其环境弹出，返回之前环境。在其内部所定义的变量也将会全部失效，所以要了解作用域，是很重要的，如下：

```JavaScript
var a = 5;
function Fun1(){
    var b = 7;
    function Fun2(){
        var c = 9;
        //c只能在这个函数里面访问
    }
    //b只能在这个函数里访问
}

//a为全局，可以在任何地方访问。
```

### :dart:延长作用域链 ###

虽然执行环境的类型总共只有两种---全局与局部（函数），但还是可以延长作用域链，当执行流进入下列任何一个语句时，作用域链就会得到加长：

 * try-catch语句的catch块
 
 * with语句
 
这两个语句都会在作用域链中前添加一个变量对象，对with语句来说，会指定的对象添加到作用域中。

### :dart:没有块级作用域 ###

不像其他语言，Js没有块级作用域，所谓块级作用域就是一个花括号为一个作用域，如下在Js中是完全可行的：

```JavaScript
var i = 0;
while(i<5)
{
    var b = 1;
    //b的块级作用域
    if(i%2==0)
    {
       var c = 3;
       //c的块级作用域
    }
    i++;
}
alert(i);
alert(b);
alert(c);
```

在其他类C语言中都是存在着块级作用域的，对于Js，没有块级作用域，除了函数，都可以访问。

<p id="a3"></p>

## 	:hourglass:垃圾收集 ## 

:arrow_double_up:<a href = "#title">返回目录</a>

JS具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存，在编写Js，不用担心内存问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种机制原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存，为此，垃圾收集器会按照固定的时间间隔周期性的执行这一操作。

### :dart:标记清除 ###

Js常用的就是标记清除吗，当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能会用到他们，当环境变量离开时，则将其标记为“离开环境”

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中变量以及被环境中的变量引用的变量的标记。而在之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后垃圾收集器完成内存清除工作，销毁那些带有标记的值，并回收他们所占用的空间。

### :dart:引用计数 ###

另一种是引用计数，其含义就是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给这个变量时，则这个值引用次数就是1，如果再被引用，就再次加1，相反，这个变量被赋了另外一个值，则这个值减1，当减为0时，则说明没有办法访问这个变量，因而就可以将其占用的内存空间收回来，这样当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。










